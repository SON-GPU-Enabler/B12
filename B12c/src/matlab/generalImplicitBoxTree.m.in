%% A MATLAB class for storing boxes in an implicit box tree on @arch@ memory,
% i.e. it stores subboxes resulting from a surrounding box and a subdividing scheme with the benefits of both a tree structure and a linear storage.
% @parallelText@
% Note that the assignment operator only acts as a copy-by-reference.

classdef @ImplicitBoxTreeType@ < handle
    properties (SetAccess = private, Hidden = true)
        objectHandle; % Handle to the underlying C++ class instance
    end
    properties (SetAccess = private)
        dim; % dimension / template parameter
        precision; % single or double / template parameter
        maxDepth; % maximal possible depth / template parameter
    end
    methods
        %% Constructor - Create a new C++ class instance 
        function this = @ImplicitBoxTreeType@(varargin)
            % @ImplicitBoxTreeType@ @ImplicitBoxTreeType@(fileName, {dim, precision, maxDepth}) loads an object from file fileName; @ImplicitBoxTreeType@(center, radius, {dim, precision, maxDepth}) creates an object with a surrounding box out of center and radius; @ImplicitBoxTreeType@(center, radius, sdScheme, {dim, precision, maxDepth}) creates an object like @ImplicitBoxTreeType@(center,radius, {dim, precision, maxDepth}) but with subdividing scheme sdScheme, which is periodically continued; @ImplicitBoxTreeType@([omp|tbb|gpu]ImplicitBoxTree[, {dim, precision, maxDepth}]) creates a deep copy
            if nargin == 0
                [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                @implicit_box_tree_interface_mex_func@('new_no_input', 0, uint64(0), '', uint64(0));
            elseif iscell(varargin{1})
                assert(isnumeric(varargin{1}{1}) && isscalar(varargin{1}{1}) && varargin{1}{1} > 0, ...
                       'First element of the cell array must be numeric and scalar.');
                assert(strcmpi(varargin{1}{2}, 'double') || strcmpi(varargin{1}{2}, 'single') || ...
                       strcmpi(varargin{1}{2}, 'float'), ...
                       'Second element of the cell array must be ''double'', ''single'', or ''float''.');
                assert(isnumeric(varargin{1}{3}) && isscalar(varargin{1}{3}) && varargin{1}{3} > 0, ...
                       'Third element of the cell array must be numeric, scalar, and positive.');
                [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                @implicit_box_tree_interface_mex_func@( ...
                    'new_default', 0, uint64(varargin{1}{1}), varargin{1}{2}, uint64(varargin{1}{3}));
            elseif isa(varargin{1}, 'ImplicitBoxTree') || isa(varargin{1}, 'ompImplicitBoxTree') || ...
                   isa(varargin{1}, 'tbbImplicitBoxTree') || isa(varargin{1}, 'gpuImplicitBoxTree')
                if nargin < 2
                    varargin{2}{1} = varargin{1}.dim;
                    varargin{2}{2} = varargin{1}.precision;
                    varargin{2}{3} = varargin{1}.maxDepth;
                end
                assert(iscell(varargin{2}), 'Second argument must be a cell array.');
                assert(isnumeric(varargin{2}{1}) && isscalar(varargin{2}{1}) && varargin{2}{1} > 0, ...
                       'First element of the cell array must be numeric and scalar.');
                assert(strcmpi(varargin{2}{2}, 'double') || strcmpi(varargin{2}{2}, 'single') || ...
                       strcmpi(varargin{2}{2}, 'float'), ...
                       'Second element of the cell array must be ''double'', ''single'', or ''float''.');
                assert(isnumeric(varargin{2}{3}) && isscalar(varargin{2}{3}) && varargin{2}{3} > 0, ...
                       'Third element of the cell array must be numeric, scalar, and positive.');
                if isa(varargin{1}, 'ImplicitBoxTree')
                    [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                    @implicit_box_tree_interface_mex_func@( ...
                        'new_ImplicitBoxTree', 0, uint64(varargin{2}{1}), varargin{2}{2}, uint64(varargin{2}{3}), ...
                        varargin{1}.objectHandle, varargin{1}.dim, varargin{1}.precision, varargin{1}.maxDepth);
                elseif isa(varargin{1}, 'ompImplicitBoxTree')
                    [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                    @implicit_box_tree_interface_mex_func@( ...
                        'new_ompImplicitBoxTree', 0, uint64(varargin{2}{1}), varargin{2}{2}, uint64(varargin{2}{3}), ...
                        varargin{1}.objectHandle, varargin{1}.dim, varargin{1}.precision, varargin{1}.maxDepth);
                elseif isa(varargin{1}, 'tbbImplicitBoxTree')
                    [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                    @implicit_box_tree_interface_mex_func@( ...
                        'new_tbbImplicitBoxTree', 0, uint64(varargin{2}{1}), varargin{2}{2}, uint64(varargin{2}{3}), ...
                        varargin{1}.objectHandle, varargin{1}.dim, varargin{1}.precision, varargin{1}.maxDepth);
                else
                    [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                    @implicit_box_tree_interface_mex_func@( ...
                        'new_gpuImplicitBoxTree', 0, uint64(varargin{2}{1}), varargin{2}{2}, uint64(varargin{2}{3}), ...
                        varargin{1}.objectHandle, varargin{1}.dim, varargin{1}.precision, varargin{1}.maxDepth);
                end
            elseif ischar(varargin{1})
                assert(nargin >= 2 && iscell(varargin{2}), 'Second argument must be a cell array.');
                assert(numel(varargin{2}) >= 3, ...
                       'Second argument must have three elements: dimension, precision, maxDepth.');
                assert(isnumeric(varargin{2}{1}) && isscalar(varargin{2}{1}) && varargin{2}{1} > 0, ...
                       'First element of the cell array must be numeric and scalar.');
                assert(strcmpi(varargin{2}{2}, 'double') || strcmpi(varargin{2}{2}, 'single') || ...
                       strcmpi(varargin{2}{2}, 'float'), ...
                       'Second element of the cell array must be ''double'', ''single'', or ''float''.');
                assert(isnumeric(varargin{2}{3}) && isscalar(varargin{2}{3}) && varargin{2}{3} > 0, ...
                       'Third element of the cell array must be numeric, scalar, and positive.');
                [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                @implicit_box_tree_interface_mex_func@( ...
                    'new_file', 0, uint64(varargin{2}{1}), varargin{2}{2}, uint64(varargin{2}{3}), varargin{1});
            else
                assert(nargin >= 3, ...
                       ['If the first argument is neither a [omp|tbb|gpu]ImplicitBoxTree nor a character string, ' ...
                        'at least three arguments are required.']);
                assert(isnumeric(varargin{1}), 'First argument must be numeric.');
                assert(isnumeric(varargin{2}), 'Second argument must be numeric.');
                assert(isnumeric(varargin{3}) || iscell(varargin{3}), ...
                       'Third argument must be numeric or a cell array.');
                if isnumeric(varargin{3})
                    assert(iscell(varargin{4}), ...
                           'Fourth argument must be a cell array when the third argument is numeric.');
                end
                if iscell(varargin{3})
                    varargin{4} = varargin{3};
                    assert(isnumeric(varargin{4}{1}) && isscalar(varargin{4}{1}) && varargin{4}{1} > 0, ...
                           'First element of the cell array must be numeric, scalar, and positive.');
                    varargin{3} = 1:varargin{4}{1};
                end
                assert(all(varargin{3} == floor(varargin{3})) && all(varargin{3} > 0), ...
                       'Elements of the third argument, if numeric, must be integer and postive.');
                assert(isnumeric(varargin{4}{1}) && isscalar(varargin{4}{1}) && varargin{4}{1} > 0, ...
                       'First element of the cell array must be numeric, scalar, and positive.');
                assert(strcmpi(varargin{4}{2}, 'double') || strcmpi(varargin{4}{2}, 'single') || ...
                       strcmpi(varargin{4}{2}, 'float'), ...
                       'Second element of the cell array must be ''double'', ''single'', or ''float''.');
                assert(isnumeric(varargin{4}{3}) && isscalar(varargin{4}{3}) && varargin{4}{3} > 0, ...
                       'Third element of the cell array must be numeric, scalar, and positive.');
                [this.objectHandle, this.dim, this.precision, this.maxDepth] = ...
                @implicit_box_tree_interface_mex_func@( ...
                    'new_vectors', 0, uint64(varargin{4}{1}), varargin{4}{2}, uint64(varargin{4}{3}), ...
                    cast(varargin{1}, varargin{4}{2}), cast(varargin{2}, varargin{4}{2}), uint64(varargin{3}));
            end
        end
        
        %% Destructor - Destroy the C++ class instance
        function delete(this)
            % destroys the object freeing the corresponding memory
            if ~isempty(this.objectHandle)
                @implicit_box_tree_interface_mex_func@( ...
                    'delete', this.objectHandle, this.dim, this.precision, this.maxDepth);
            end
        end

        %% Member functions
        
        function res = areAllLeavesOnDepth(this, depth)
            % checks whether all leaves have a given Depth depth
            assert(isnumeric(depth) && isscalar(depth), 'Argument must be numeric and scalar.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'areAllLeavesOnDepth', this.objectHandle, this.dim, this.precision, this.maxDepth, int64(depth));
        end
        
        function res = boxes(this, depth)
            % returns a (2*dim+1,count(depth))-matrix whose columns have the form [center; radius; flags] representing a box in Depth depth (default=-1)
            if nargin < 2
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Argument must be numeric and scalar.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'boxes', this.objectHandle, this.dim, this.precision, this.maxDepth, int64(depth));
        end
        
        function res = center(this, vector)
            % returns the center coordinates of the surrounding box; an input vector resets this vector
            if nargin < 2
                res = @implicit_box_tree_interface_mex_func@( ...
                    'center', this.objectHandle, this.dim, this.precision, this.maxDepth);
            else
                assert(isnumeric(vector) && length(vector) == this.dim, ...
                       'Argument must be numeric and have the same dimension as the tree.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'center', this.objectHandle, this.dim, this.precision, this.maxDepth, cast(vector, this.precision));
            end
        end
        
        function res = changeFlags(this, input, flagsToUnset, flagsToSet, depth)
            % changes the Flags flagsToUnset to flagsToSet in Depth depth (default=-1) in all boxes if input='all', in those boxes whose corresponding entry in a logical input is true, in those boxes that are hit by the points given by the columns of the input, or those boxes that are hit by the points computed via mapped grid points of boxes that have Flags flagsToCheck set if the input has the form {GridFunctor, MapFunctor (default=Identity), Depth depth (default=-1), Flags flagsToCheck (default=NONE)}
            if nargin < 5
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Fourth argument must be numeric and scalar.');
            assert(isnumeric(flagsToUnset) && isscalar(flagsToUnset) && flagsToUnset >= 0 && flagsToUnset < 256, ...
                   'Second argument must be numeric, scalar, and between 0 and 255.');
            assert(isnumeric(flagsToSet) && isscalar(flagsToSet) && flagsToSet >= 0 && flagsToSet < 256, ...
                   'Third argument must be numeric, scalar, and between 0 and 255.');
            if strcmpi(input,'all')
                res = @implicit_box_tree_interface_mex_func@( ...
                    'changeFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'all', uint64(flagsToUnset), uint64(flagsToSet), int64(depth));
            elseif islogical(input)
                assert(numel(input) == this.count(depth), ...
                       ['First argument must have as many elements as number of boxes in Depth depth ' ...
                        'when it is logical.']);
                res = @implicit_box_tree_interface_mex_func@( ...
                    'changeFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'logical', input, uint64(flagsToUnset), uint64(flagsToSet), int64(depth));
            elseif isnumeric(input)
                assert(size(input,1) == this.dim, 'First argument must have dim rows when it is numeric.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'changeFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'points', cast(input, this.precision), uint64(flagsToUnset), uint64(flagsToSet), int64(depth));
            elseif iscell(input)
                if numel(input) < 4
                    if numel(input) < 3
                        if numel(input) < 2
                            input{2} = MapFunctor('Identity', this.dim, []);
                        end
                        input{3} = -1;
                    end
                    input{4} = 0;
                end
                assert(isa(input{1}, 'GridFunctor'), ...
                       'First element of the first argument must be a GridFunctor when it is a cell array.');
                assert(input{1}.dim == this.dim, ...
                       'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isa(input{2}, 'MapFunctor'), ...
                       'Second element of the first argument must be a MapFunctor when it is a cell array.');
                assert(input{2}.dim == this.dim, ...
                       'MapFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isnumeric(input{3}) && isscalar(input{3}), ...
                       'Third element of the first argument must be numeric and scalar.');
                assert(isnumeric(input{4}) && isscalar(input{4}) && input{4} >= 0 && input{4} < 256, ...
                       'Fourth element of the first argument must be numeric, scalar, and between 0 and 255.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'changeFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'cell', input{1}.gridType, uint64(input{1}.params), input{2}.mapType, double(input{2}.params), ...
                    int64(input{3}), uint64(input{4}), uint64(flagsToUnset), uint64(flagsToSet), int64(depth));
            else
                error('ChangeFlags: Invalid argument.');
            end
        end
        
        function res = count(this, depth)
            % returns the number of boxes on Depth depth (default=-1)
            if nargin < 2
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Argument must be numeric and scalar.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'count', this.objectHandle, this.dim, this.precision, this.maxDepth, int64(depth));
        end
        
        function res = deleteDepth(this, depth)
            % deletes all boxes on Depth depth, i.e. afterwards the tree has at most Depth depth-1; returns the number of deleted boxes on Depth depth
            assert(isnumeric(depth) && isscalar(depth), 'Argument must be numeric and scalar.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'deleteDepth', this.objectHandle, this.dim, this.precision, this.maxDepth, int64(depth));
        end
        
        function res = depth(this)
            % returns the current maximal depth of the tree
            res = @implicit_box_tree_interface_mex_func@( ...
                'depth', this.objectHandle, this.dim, this.precision, this.maxDepth);
        end
        
        function res = depths(this)
            % returns the Depths of the leaves
            res = @implicit_box_tree_interface_mex_func@( ...
                'depths', this.objectHandle, this.dim, this.precision, this.maxDepth);
        end
        
        function res = diameter(this, method)
            % computes the diameters of this' box collection in all depths; possible methods: 'vol' as geometric mean of all box diameters, 'diag' as diagonal divided by the dimension, 'mean' as arithmetic mean, 'min' as minimum, 'max' as maximum, 'diam' as 2-norm, 'harm' as harmonic mean
            if nargin < 2
                method = '';
            end
            sdScheme = this.sdScheme;
            edges = 2 * this.radius;
            d = this.depth + 1;
            res = zeros(d, 1);
            for i = 1:d
                if strcmpi(method, 'vol')
                    res(i) = prod(edges) ^ (1 / double(this.dim));
                elseif strcmpi(method, 'diag')
                    res(i) = sqrt(sum(edges .^ 2) / double(this.dim));
                elseif strcmpi(method, 'mean')
                    res(i) = sum(edges) / double(this.dim);
                elseif strcmpi(method, 'min')
                    res(i) = min(edges);
                elseif strcmpi(method, 'max')
                    res(i) = max(edges);
                elseif strcmpi(method, 'diam')
                    res(i) = sqrt(sum(edges .^ 2));
                elseif strcmpi(method, 'harm')
                    res(i) = double(this.dim) ./ sum(1 ./ edges);
                else
                    res(i) = exp(1);
                end
                edges(sdScheme(i)) = edges(sdScheme(i)) / 2;
            end
        end
        
        function res = enumerate(this)
            % returns the vector [count(0); ...; count(depth())]
            res = @implicit_box_tree_interface_mex_func@( ...
                'enumerate', this.objectHandle, this.dim, this.precision, this.maxDepth);
        end
        
        function res = flags(this)
            % returns the Flags of the leaves
            res = @implicit_box_tree_interface_mex_func@( ...
                'flags', this.objectHandle, this.dim, this.precision, this.maxDepth);
        end
        
        function res = gridPoints(this, gridFunctor, depth, stencil)
            % returns the grid points of the @ImplicitBoxTreeType@ on a given Depth (default=-1) with respect to a GridFunctor; only boxes are used whose entry in stencil (default=true(1,this.count(depth))) is true
            if nargin < 3
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Second argument must be numeric and scalar.');
            nrb = this.count(depth);
            if nargin < 4
                stencil = true(1, nrb);
            end
            assert(isa(gridFunctor, 'GridFunctor'), 'First element must be a GridFunctor.');
            assert(gridFunctor.dim == this.dim, 'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
            assert(islogical(stencil) && numel(stencil) == nrb, ...
                   'Third argument must be a (logical) vector with as many elements as the number of boxes in the given depth.');
            b = this.boxes(depth);
            dim = this.dim;
            res = reshape(bsxfun(@plus, ...
                                 reshape(b(1:dim, stencil), dim, 1, []), ...
                                 bsxfun(@times, ...
                                        reshape(b(dim+1:2*dim, stencil), dim, 1, []), ...
                                        reshape(gridFunctor.points(1:gridFunctor.nPointsPerBox(), true, '@parallelMethod@'), dim, [], 1))), ...
                          dim, ...
                          []);
        end
        
        function res = hasSameBoxes(this, ibt)
            % checks whether both objects represent the same box collection
            if ~strcmp(class(this), class(ibt))
                ibt = @ImplicitBoxTreeType@(ibt);
            end
            res = @implicit_box_tree_interface_mex_func@( ...
                'hasSameBoxes', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                ibt.objectHandle, ibt.dim, ibt.precision, ibt.maxDepth);
        end
            
        function initializeIndicesInDepth(this, depth)
            % initialises a vector containing the index for each box the ancestor box in Depth depth has
            @implicit_box_tree_interface_mex_func@( ...
                'initializeIndicesInDepth', this.objectHandle, this.dim, this.precision, this.maxDepth, int64(depth));
        end
            
        function initializeLeafIndicesFromDepth(this, depth, flags)
            % initialises a vector containing the leaf indices where in the @ImplicitBoxTreeType@ a "new" Box in Depth depth "starts" that has Flags flags set
            if nargin < 3
                flags = 0;
            end
            @implicit_box_tree_interface_mex_func@( ...
                'initializeLeafIndicesFromDepth', this.objectHandle, this.dim, this.precision, this.maxDepth, int64(depth), uint64(flags));
        end
        
        function res = insert(this, input, depth, flagsForInserted, flagsForHit)
            % inserts the boxes on Depth depth which contain the points given by the columns of input or the points computed by the scheme {GridFunctor, MapFunctor (default=Identity), Depth depth (default=-1), Flags flagsToCheck (default=NONE)}; each newly created box gets the Flags flagsForInserted (default=2), others the Flags flagsForHit (default=0); returns a logical vector whose elements are 1 iff for the corresponding point a box was created, otherwise 0
            if nargin < 5
                flagsForHit = 0;
            end
            if nargin < 4
                flagsForInserted = 2;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Second argument must be numeric and scalar.');
            assert(isnumeric(flagsForInserted) && isscalar(flagsForInserted) && flagsForInserted >= 0 && ...
                   flagsForInserted < 256, ...
                   'Third argument must be numeric, scalar, and between 0 and 255.');
            assert(isnumeric(flagsForHit) && isscalar(flagsForHit) && flagsForHit >= 0 && flagsForHit < 256, ...
                   'Fourth argument must be numeric, scalar, and between 0 and 255.');
            if isnumeric(input)
                assert(size(input,1) == this.dim, 'First argument must have dim rows when it is numeric.');
                if nargout == 0
                    @implicit_box_tree_interface_mex_func@( ...
                        'insert', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                        'points', cast(input, this.precision), int64(depth), uint64(flagsForInserted), ...
                        uint64(flagsForHit));
                else
                    res = @implicit_box_tree_interface_mex_func@( ...
                        'insert', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                        'points', cast(input, this.precision), int64(depth), uint64(flagsForInserted), ...
                        uint64(flagsForHit));
                end
            elseif iscell(input)
                if numel(input) < 4
                    if numel(input) < 3
                        if numel(input) < 2
                            input{2} = MapFunctor('Identity', this.dim, []);
                        end
                        input{3} = -1;
                    end
                    input{4} = 0;
                end
                assert(isa(input{1}, 'GridFunctor'), ...
                       'First element of the first argument must be a GridFunctor when it is a cell array.');
                assert(input{1}.dim == this.dim, ...
                       'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isa(input{2}, 'MapFunctor'), ...
                       'Second element of the first argument must be a MapFunctor when it is a cell array.');
                assert(input{2}.dim == this.dim, ...
                       'MapFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isnumeric(input{3}) && isscalar(input{3}), ...
                       'Third element of the first argument must be numeric and scalar.');
                assert(isnumeric(input{4}) && isscalar(input{4}) && input{4} >= 0 && input{4} < 256, ...
                       'Fourth element of the first argument must be numeric, scalar, and between 0 and 255.');
                if nargout == 0
                    @implicit_box_tree_interface_mex_func@( ...
                        'insert', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                        'cell', input{1}.gridType, uint64(input{1}.params), ...
                        input{2}.mapType, double(input{2}.params), int64(input{3}), uint64(input{4}), ...
                        int64(depth), uint64(flagsForInserted), uint64(flagsForHit));
                else
                    res = @implicit_box_tree_interface_mex_func@( ...
                        'insert', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                        'cell', input{1}.gridType, uint64(input{1}.params), ...
                        input{2}.mapType, double(input{2}.params), int64(input{3}), uint64(input{4}), ...
                        int64(depth), uint64(flagsForInserted), uint64(flagsForHit));
                end
            else
                error('Insert: Invalid argument.');
            end
            
        end
        
        function res = nHostBufferBytes(this, n)
            % returns the number of bytes that host algorithms can temporarily allocate; an input value resets this number
            if nargin < 2
                res = @implicit_box_tree_interface_mex_func@( ...
                    'nHostBufferBytes', this.objectHandle, this.dim, this.precision, this.maxDepth);
            else
                assert(isnumeric(n) && isscalar(n) && n > 0, 'Argument must be numeric, scalar, and greater than 0.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'nHostBufferBytes', this.objectHandle, this.dim, this.precision, this.maxDepth, uint64(n));
            end
        end
        
        function res = plot(this, depth, C, varargin)
            % plots the box covering on Depth depth (default=-1) with face colors determined by C (also see patch; but for dim > 2, one row stands for the six faces of one box); returns the patch object; the vector after possible option ''Dim'' determines the dimensions to plot (default=1:min(this.dim,3)); the vector after possible option ''Stencil'' determines the boxes to plot (default=true(1,this.count(depth))); other input arguments are passed to patch
            if nargin < 3
                if nargin < 2
                    depth = -1;
                end
                C = [1 0 0];
            end
            if isrow(C) && numel(C) ~= 3
                C = C';
            end
            b = this.boxes(depth);
            dimvec = 1:min(this.dim, 3);
            j = 0;
            for i = 1:numel(varargin)
                if strcmpi(varargin{i}, 'Dim')
                    dimvec = varargin{i+1};
                    j = i;
                end
            end
            if j ~= 0
                varargin = {varargin{1:j-1} , varargin{j+2:end}};
            end
            dims = numel(dimvec);
            stencil = true(1, size(b, 2));
            j = 0;
            for i = 1:numel(varargin)
                if strcmpi(varargin{i}, 'Stencil')
                    stencil = logical(varargin{i+1});
                    j = i;
                end
            end
            if j ~= 0
                varargin = {varargin{1:j-1} , varargin{j+2:end}};
            end
            assert(isnumeric(depth) && isscalar(depth), 'First argument must be numeric and scalar.');
            assert(isnumeric(dimvec) && (dims == 2 || dims == 3) && min(dimvec(:)) >= 1 && max(dimvec(:)) <= this.dim, ...
                   ['Argument after ''Dim'' must be a numeric vector with 2 or 3 elements ' ...
                    'that are between 1 and this.dim.']);
            assert(islogical(stencil) && numel(stencil) == size(b, 2), ...
                   'Argument after ''Stencil'' must be a (logical) vector with as many elements as the number of boxes in the given depth.');
            b = b([dimvec(:) ; dimvec(:) + double(this.dim)], stencil);
            center = this.center; center = center(dimvec(:));
            radius = this.radius; radius = radius(dimvec(:));
            axisvec = [center(:)' - radius(:)' ; center(:)' + radius(:)'];
            axisvec = axisvec(:)';
            if dims == 2
                if size(C, 1) ~= 1
                    if ndims(C) == 3
                        C = C(stencil, :, :);
                    else
                        C = C(stencil);
                    end
                    colorbar;
                end
                axis(axisvec);
                btemp = b(3, :);
                b(3, :) = b(3, :) + b(1, :);
                b(1, :) = b(1, :) - btemp;
                btemp = b(4, :);
                b(4, :) = b(4, :) + b(2, :);
                b(2, :) = b(2, :) - btemp;
                clear btemp;
                res = patch([b(1, :); b(3, :); b(3, :); b(1, :)], ...
                            [b(2, :); b(2, :); b(4, :); b(4, :)], ...
                            C, varargin{:});
            else
                if size(C, 1) ~= 1
                    C = C(stencil);
                    C = reshape(repmat(C, 1, 6)', size(C, 2), size(C, 1) * 6)';
                    colorbar;
                end
                axis(axisvec);
                nrb = size(b,2);
                btemp = b(4, :);
                b(4, :) = b(4, :) + b(1, :);
                b(1, :) = b(1, :) - btemp;
                btemp = b(5, :);
                b(5, :) = b(5, :) + b(2, :);
                b(2, :) = b(2, :) - btemp;
                btemp = b(6, :);
                b(6, :) = b(6, :) + b(3, :);
                b(3, :) = b(3, :) - btemp;
                clear btemp;
                v = [reshape([b(1, :); b(4, :); b(4, :); b(1, :); b(1, :); b(4, :); b(4, :); b(1, :)], 8*nrb, 1), ...
                     reshape([b(2, :); b(2, :); b(5, :); b(5, :); b(2, :); b(2, :); b(5, :); b(5, :)], 8*nrb, 1), ...
                     reshape([b(3, :); b(3, :); b(3, :); b(3, :); b(6, :); b(6, :); b(6, :); b(6, :)], 8*nrb, 1)];
                f = repmat([1 2 3 4; 1 4 8 5; 1 2 6 5; 2 3 7 6; 3 4 8 7; 5 6 7 8], nrb, 1) + ...
                    8 * reshape(repmat(0:nrb-1, 24, 1), 4, 6*nrb)';
                res = patch('Faces', f, 'Vertices', v, 'FaceVertexCData', C, 'FaceColor', 'flat', varargin{:});
                view(3);
                grid on;
                xlabel(['x_' num2str(dimvec(1))]);
                ylabel(['x_' num2str(dimvec(2))]);
                zlabel(['x_' num2str(dimvec(3))]);
            end
        end
        
        function res = radius(this, vector)
            % returns the radius coordinates of the surrounding box; an input vector resets this vector
            if nargin < 2
                res = @implicit_box_tree_interface_mex_func@( ...
                    'radius', this.objectHandle, this.dim, this.precision, this.maxDepth);
            else
                assert(isnumeric(vector) && length(vector) == this.dim && min(vector) >= 0, ...
                       'Argument must be numeric, have the same dimension as the tree, and have non-negative entries.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'radius', this.objectHandle, this.dim, this.precision, this.maxDepth, cast(vector, this.precision));
            end
        end
        
        function res = remove(this, flags)
            % removes all leaves (and corresponding parents) which have the Flags flags NOT set; returns the number of removed leaves
            assert(isnumeric(flags) && isscalar(flags) && flags >= 0 && flags < 256, ...
                   'First argument must be numeric, scalar, and between 0 and 255.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'remove', this.objectHandle, this.dim, this.precision, this.maxDepth, uint64(flags));
        end
        
        function reserve(this, n)
            % if n is less than or equal to the current capacity, this call has no effect; otherwise, this method is a request for allocation of additional memory such that at least n boxes can be stored; the current size is unchanged.
            assert(isnumeric(n) && isscalar(n), 'Argument must be numeric and scalar.');
            @implicit_box_tree_interface_mex_func@( ...
                'reserve', this.objectHandle, this.dim, this.precision, this.maxDepth, uint64(n));
        end
        
        function save(this, fileName)
            % stores the object in file fileName such that a new object can be created via @ImplicitBoxTreeType@(fileName)
            assert(ischar(fileName), 'First argument must be a character array/string.');
            @implicit_box_tree_interface_mex_func@( ...
                'save', this.objectHandle, this.dim, this.precision, this.maxDepth, fileName);
        end
        
        function saveForGaio(this, fileName)
            % stores the object in file fileName such that a GAIO Tree can be created via readForGaio(fileName)
            assert(ischar(fileName), 'First argument must be a character array/string.');
            @implicit_box_tree_interface_mex_func@( ...
                'saveForGaio', this.objectHandle, this.dim, this.precision, this.maxDepth, fileName);
        end
        
        function res = sdScheme(this, vector)
            % returns the subdividing scheme; an input vector resets this scheme
            if nargin < 2
                res = @implicit_box_tree_interface_mex_func@( ...
                    'sdScheme', this.objectHandle, this.dim, this.precision, this.maxDepth);
            else
                assert(isnumeric(vector) && min(vector) >= 1 && max(vector) <= this.dim, ...
                       'Argument must be numeric and have values between 1 and the dimension of the tree.');
                % handle different base indexing
                res = @implicit_box_tree_interface_mex_func@( ...
                    'sdScheme', this.objectHandle, this.dim, this.precision, this.maxDepth, uint64(vector));
            end
        end
        
        function res = search(this, input, depth)
            % searches for the points given by the columns of points on Depth depth (default=-1) or the points computed by the scheme {GridFunctor, MapFunctor (default=Identity), Depth depth (default=-1), Flags flagsToCheck (default=NONE)}; returns a vector whose entries either denote the number of the box the corresponding point is contained in or 0
            if nargin < 3
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Second argument must be numeric and scalar.');
            if isnumeric(input)
                assert(size(input,1) == this.dim, 'First argument must have dim rows when it is numeric.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'search', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'points', cast(input, this.precision), int64(depth));
            elseif iscell(input)
                if numel(input) < 4
                    if numel(input) < 3
                        if numel(input) < 2
                            input{2} = MapFunctor('Identity', this.dim, []);
                        end
                        input{3} = -1;
                    end
                    input{4} = 0;
                end
                assert(isa(input{1}, 'GridFunctor'), ...
                       'First element of the first argument must be a GridFunctor when it is a cell array.');
                assert(input{1}.dim == this.dim, ...
                       'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isa(input{2}, 'MapFunctor'), ...
                       'Second element of the first argument must be a MapFunctor when it is a cell array.');
                assert(input{2}.dim == this.dim, ...
                       'MapFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isnumeric(input{3}) && isscalar(input{3}), ...
                       'Third element of the first argument must be numeric and scalar.');
                assert(isnumeric(input{4}) && isscalar(input{4}) && input{4} >= 0 && input{4} < 256, ...
                       'Fourth element of the first argument must be numeric, scalar, and between 0 and 255.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'search', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'cell', input{1}.gridType, uint64(input{1}.params), input{2}.mapType, double(input{2}.params), ...
                    int64(input{3}), uint64(input{4}), int64(depth));
            else
                error('Search: Invalid argument.');
            end
        end
        
        function res = setFlags(this, input, flags, depth)
            % sets the Flags flags in Depth depth (default=-1) in all boxes if input='all', in those boxes whose corresponding entry in a logical input is true, in those boxes that are hit by the points given by the columns of the input, or those boxes that are hit by the points computed via mapped grid points of boxes that have Flags flagsToCheck set if the input has the form {GridFunctor, MapFunctor (default=Identity), Depth depth (default=-1), Flags flagsToCheck (default=NONE)}
            if nargin < 4
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Third argument must be numeric and scalar.');
            assert(isnumeric(flags) && isscalar(flags) && flags >= 0 && flags < 256, ...
                   'Second argument must be numeric, scalar, and between 0 and 255.');
            if strcmpi(input,'all')
                res = @implicit_box_tree_interface_mex_func@( ...
                    'setFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'all', uint64(flags), int64(depth));
            elseif islogical(input)
                assert(numel(input) == this.count(depth), ...
                       ['First argument must have as many elements as number of boxes in Depth depth ' ...
                        'when it is logical.']);
                res = @implicit_box_tree_interface_mex_func@( ...
                    'setFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'logical', input, uint64(flags), int64(depth));
            elseif isnumeric(input)
                assert(size(input,1) == this.dim, 'First argument must have dim rows when it is numeric.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'setFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'points', cast(input, this.precision), uint64(flags), int64(depth));
            elseif iscell(input)
                if numel(input) < 4
                    if numel(input) < 3
                        if numel(input) < 2
                            input{2} = MapFunctor('Identity', this.dim, []);
                        end
                        input{3} = -1;
                    end
                    input{4} = 0;
                end
                assert(isa(input{1}, 'GridFunctor'), ...
                       'First element of the first argument must be a GridFunctor when it is a cell array.');
                assert(input{1}.dim == this.dim, ...
                       'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isa(input{2}, 'MapFunctor'), ...
                       'Second element of the first argument must be a MapFunctor when it is a cell array.');
                assert(input{2}.dim == this.dim, ...
                       'MapFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isnumeric(input{3}) && isscalar(input{3}), ...
                       'Third element of the first argument must be numeric and scalar.');
                assert(isnumeric(input{4}) && isscalar(input{4}) && input{4} >= 0 && input{4} < 256, ...
                       'Fourth element of the first argument must be numeric, scalar, and between 0 and 255.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'setFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'cell', input{1}.gridType, uint64(input{1}.params), input{2}.mapType, double(input{2}.params), ...
                    int64(input{3}), uint64(input{4}), uint64(flags), int64(depth));
            else
                error('SetFlags: Invalid argument.');
            end
        end
            
        function shrinkToFit(this)
            % shrinks the capacity of the ''box vectors'' to exactly fit their elements.
            @implicit_box_tree_interface_mex_func@( ...
                'shrinkToFit', this.objectHandle, this.dim, this.precision, this.maxDepth);
        end
        
        function res = subdivide(this, flags)
            % subdivides all leaves which have the Flags flags set; returns the number of subdivided boxes
            if nargin < 2
                flags = 8;
            end
            assert(isnumeric(flags) && isscalar(flags) && flags >= 0 && flags < 256, ...
                   'First argument must be numeric, scalar, and between 0 and 255.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'subdivide', this.objectHandle, this.dim, this.precision, this.maxDepth, uint64(flags));
        end
            
        function res = subsetRatio(this, ibt, depths1, depths2)
            % compares the box collections (neglecting Flags) of two given [omp|tbb|gpu]ImplicitBoxTrees given by the depths1 (default=0:min(this.depth,ibt.depth)) or depths2 (default=depths1), respectively; returns a matrix with two columns: in the first column, the i-th entry gives the ratio of this' boxes in Depth depths1(i) that also appear in ibt's box collection in Depth depths2(i); the second column works vice versa
            if nargin < 4
                if nargin < 3
                    depths1 = 0:min(this.depth,ibt.depth);
                end
                depths2 = depths1;
            end
            assert(isa(ibt, 'ImplicitBoxTree') || isa(ibt, 'gpuImplicitBoxTree'), ...
                   'First argument must be an [omp|tbb|gpu]ImplicitBoxTree.');
            assert(this.dim == ibt.dim, 'Both [omp|tbb|gpu]ImplicitBoxTrees must have the same dimension.');
            assert(numel(depths1) == numel(depths2), 'depths1 and depths2 must have the same number of elements.');
            res = zeros(numel(depths1), 2);
            for i = 1:numel(depths1)
                b1 = this.boxes(depths1(i))';
                b1 = b1(:, 1:2*this.dim);
                b2 = ibt.boxes(depths2(i))';
                b2 = b2(:, 1:2*this.dim);
                res(i,1) = sum(ismember(b1, b2, 'rows')) / size(b1, 1);
                res(i,2) = sum(ismember(b2, b1, 'rows')) / size(b2, 1);
            end
        end
            
        function res = transitionMatrix(this, scheme, useAbsoluteValues, useNotFound)
            % computes and returns the right stochastic (row-stochastic) transition matrix according to the given scheme {GridFunctor, MapFunctor (default=Identity), Depth depth (default=-1), Flags flagsToCheck (default=NONE)}; if the second argument evaluates to true, the (i,j)-th matrix entry is the number of points starting in box j and being mapped into box i, otherwise each entry is furthermore divided by the number of points per box; if the third argument evaluates to true, the matrix is appended an additional column for the phase space not covered by the boxes
            if nargin < 4
                if nargin < 3
                    useAbsoluteValues = false;
                end
                useNotFound = false;
            end
            assert(iscell(scheme), 'First argument must be a cell array.');
            if numel(scheme) < 4
                if numel(scheme) < 3
                    if numel(scheme) < 2
                        scheme{2} = MapFunctor('Identity', this.dim, []);
                    end
                    scheme{3} = -1;
                end
                scheme{4} = 0;
            end
            assert(isa(scheme{1}, 'GridFunctor'), ...
                   'First element of the first argument must be a GridFunctor when it is a cell array.');
            assert(scheme{1}.dim == this.dim, 'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
            assert(isa(scheme{2}, 'MapFunctor'), ...
                   'Second element of the first argument must be a MapFunctor when it is a cell array.');
            assert(scheme{2}.dim == this.dim, 'MapFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
            assert(isnumeric(scheme{3}) && isscalar(scheme{3}), ...
                   'Third element of the first argument must be numeric and scalar.');
            assert(isnumeric(scheme{4}) && isscalar(scheme{4}) && scheme{4} >= 0 && scheme{4} < 256, ...
                   'Fourth element of the first argument must be numeric, scalar, and between 0 and 255.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'transitionMatrix', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                scheme{1}.gridType, uint64(scheme{1}.params), scheme{2}.mapType, double(scheme{2}.params), ...
                int64(scheme{3}), uint64(scheme{4}), logical(useAbsoluteValues), logical(useNotFound));
        end
        
        function res = unsetFlags(this, input, flags, depth)
            % unsets the Flags flags in Depth depth (default=-1) in all boxes if input='all', in those boxes whose corresponding entry in a logical input is true, in those boxes that are hit by the points given by the columns of the input, or those boxes that are hit by the points computed via mapped grid points of boxes that have Flags flagsToCheck set if the input has the form {GridFunctor, MapFunctor (default=Identity), Depth depth (default=-1), Flags flagsToCheck (default=NONE)}
            if nargin < 4
                depth = -1;
            end
            assert(isnumeric(depth) && isscalar(depth), 'Third argument must be numeric and scalar.');
            assert(isnumeric(flags) && isscalar(flags) && flags >= 0 && flags < 256, ...
                   'Second argument must be numeric, scalar, and between 0 and 255.');
            if strcmpi(input,'all')
                res = @implicit_box_tree_interface_mex_func@( ...
                    'unsetFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'all', uint64(flags), int64(depth));
            elseif islogical(input)
                assert(numel(input) == this.count(depth), ...
                       ['First argument must have as many elements as number of boxes in Depth depth ' ...
                        'when it is logical.']);
                res = @implicit_box_tree_interface_mex_func@( ...
                    'unsetFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'logical', input, uint64(flags), int64(depth));
            elseif isnumeric(input)
                assert(size(input,1) == this.dim, ...
                       'First argument must have dim rows when it is numeric.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'unsetFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'points', cast(input, this.precision), uint64(flags), int64(depth));
            elseif iscell(input)
                if numel(input) < 4
                    if numel(input) < 3
                        if numel(input) < 2
                            input{2} = MapFunctor('Identity', this.dim, []);
                        end
                        input{3} = -1;
                    end
                    input{4} = 0;
                end
                assert(isa(input{1}, 'GridFunctor'), ...
                       'First element of the first argument must be a GridFunctor when it is a cell array.');
                assert(input{1}.dim == this.dim, ...
                       'GridFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isa(input{2}, 'MapFunctor'), ...
                       'Second element of the first argument must be a MapFunctor when it is a cell array.');
                assert(input{2}.dim == this.dim, ...
                       'MapFunctor must have the same dimension as the @ImplicitBoxTreeType@.');
                assert(isnumeric(input{3}) && isscalar(input{3}), ...
                       'Third element of the first argument must be numeric and scalar.');
                assert(isnumeric(input{4}) && isscalar(input{4}) && input{4} >= 0 && input{4} < 256, ...
                       'Fourth element of the first argument must be numeric, scalar, and between 0 and 255.');
                res = @implicit_box_tree_interface_mex_func@( ...
                    'unsetFlags', this.objectHandle, this.dim, this.precision, this.maxDepth, ...
                    'cell', input{1}.gridType, uint64(input{1}.params), input{2}.mapType, double(input{2}.params), ...
                    int64(input{3}), uint64(input{4}), uint64(flags), int64(depth));
            else
                error('UnsetFlags: Invalid argument.');
            end
        end
        
        function res = unsubdivide(this, flags)
            % unsubdivides all leaves whose parent has the Flags flags set; returns the number of unsubdivided boxes
            if nargin < 2
                flags = 8;
            end
            assert(isnumeric(flags) && isscalar(flags) && flags >= 0 && flags < 256, ...
                   'First argument must be numeric, scalar, and between 0 and 255.');
            res = @implicit_box_tree_interface_mex_func@( ...
                'unsubdivide', this.objectHandle, this.dim, this.precision, this.maxDepth, uint64(flags));
        end
    end
end
